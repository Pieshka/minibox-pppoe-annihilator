From 37d7c8657999666baecec60e0b122b41d2de31b4 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Sat, 23 Aug 2025 13:29:12 +0200
Subject: [PATCH 2/3] soc: rockchip: add cpuinfo support

Set system_serial_low/high from eFuse ID.
Serial can read from /proc/cpuinfo.
---
 arch/arm64/include/asm/system_info.h |  14 ++
 drivers/soc/rockchip/Kconfig         |  10 +
 drivers/soc/rockchip/Makefile        |   1 +
 drivers/soc/rockchip/cpuinfo.c       | 307 +++++++++++++++++++++++++++
 include/linux/rockchip/cpu.h         | 234 ++++++++++++++++++++
 5 files changed, 566 insertions(+)
 create mode 100644 arch/arm64/include/asm/system_info.h
 create mode 100644 drivers/soc/rockchip/cpuinfo.c
 create mode 100644 include/linux/rockchip/cpu.h

diff --git a/arch/arm64/include/asm/system_info.h b/arch/arm64/include/asm/system_info.h
new file mode 100644
index 000000000000..a82fe791b2f6
--- /dev/null
+++ b/arch/arm64/include/asm/system_info.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_ARM_SYSTEM_INFO_H
+#define __ASM_ARM_SYSTEM_INFO_H
+
+#ifndef __ASSEMBLY__
+
+/* information about the system we're running on */
+extern unsigned int system_rev;
+extern unsigned int system_serial_low;
+extern unsigned int system_serial_high;
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __ASM_ARM_SYSTEM_INFO_H */
diff --git a/drivers/soc/rockchip/Kconfig b/drivers/soc/rockchip/Kconfig
index 785f60c6f3ad..1ea3b5671bbe 100644
--- a/drivers/soc/rockchip/Kconfig
+++ b/drivers/soc/rockchip/Kconfig
@@ -5,6 +5,16 @@ if ARCH_ROCKCHIP || COMPILE_TEST
 # Rockchip Soc drivers
 #
 
+config ROCKCHIP_CPUINFO
+	tristate "Rockchip cpuinfo support"
+	depends on (NVMEM_ROCKCHIP_EFUSE || NVMEM_ROCKCHIP_OTP) && (ARM64 || ARM)
+	help
+	  Say y here to enable Rockchip cpuinfo support.
+	  Set system_serial_low/high from eFuse ID.
+	  Serial can read from /proc/cpuinfo.
+
+	  If unsure, say N.
+
 config ROCKCHIP_GRF
 	bool "Rockchip General Register Files support" if COMPILE_TEST
 	default y if ARCH_ROCKCHIP
diff --git a/drivers/soc/rockchip/Makefile b/drivers/soc/rockchip/Makefile
index 23d414433c8c..2ddffa7f73d3 100644
--- a/drivers/soc/rockchip/Makefile
+++ b/drivers/soc/rockchip/Makefile
@@ -2,6 +2,7 @@
 #
 # Rockchip Soc drivers
 #
+obj-$(CONFIG_ROCKCHIP_CPUINFO) += cpuinfo.o
 obj-$(CONFIG_ROCKCHIP_GRF) += grf.o
 obj-$(CONFIG_ROCKCHIP_IODOMAIN) += io-domain.o
 obj-$(CONFIG_ROCKCHIP_DTPM) += dtpm.o
diff --git a/drivers/soc/rockchip/cpuinfo.c b/drivers/soc/rockchip/cpuinfo.c
new file mode 100644
index 000000000000..f20ad064edd2
--- /dev/null
+++ b/drivers/soc/rockchip/cpuinfo.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/crc32.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <asm/system_info.h>
+#include <linux/rockchip/cpu.h>
+
+unsigned long rockchip_soc_id;
+EXPORT_SYMBOL(rockchip_soc_id);
+
+static int rockchip_cpuinfo_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct nvmem_cell *cell;
+	unsigned char *efuse_buf, buf[16];
+	size_t len = 0;
+	int i;
+
+	cell = nvmem_cell_get(dev, "cpu-code");
+	if (!IS_ERR(cell)) {
+		efuse_buf = nvmem_cell_read(cell, &len);
+		nvmem_cell_put(cell);
+		if (IS_ERR(efuse_buf))
+			return PTR_ERR(efuse_buf);
+
+		if (len == 2)
+			rockchip_set_cpu((efuse_buf[0] << 8 | efuse_buf[1]));
+		kfree(efuse_buf);
+	}
+
+	cell = nvmem_cell_get(dev, "cpu-version");
+	if (!IS_ERR(cell)) {
+		efuse_buf = nvmem_cell_read(cell, &len);
+		nvmem_cell_put(cell);
+		if (IS_ERR(efuse_buf))
+			return PTR_ERR(efuse_buf);
+
+		if ((len == 1) && (efuse_buf[0] > rockchip_get_cpu_version()))
+			rockchip_set_cpu_version(efuse_buf[0]);
+		kfree(efuse_buf);
+	}
+
+	cell = nvmem_cell_get(dev, "id");
+	if (IS_ERR(cell))
+		return dev_err_probe(dev, PTR_ERR(cell), "failed to get id cell\n");
+
+	efuse_buf = nvmem_cell_read(cell, &len);
+	nvmem_cell_put(cell);
+	if (IS_ERR(efuse_buf))
+		return PTR_ERR(efuse_buf);
+
+	if (len != 16) {
+		kfree(efuse_buf);
+		dev_err(dev, "invalid id len: %zu\n", len);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 8; i++) {
+		buf[i] = efuse_buf[1 + (i << 1)];
+		buf[i + 8] = efuse_buf[i << 1];
+	}
+
+	kfree(efuse_buf);
+
+	dev_info(dev, "SoC\t\t: %lx\n", rockchip_soc_id);
+
+	system_serial_low = crc32(0, buf, 8);
+	system_serial_high = crc32(system_serial_low, buf + 8, 8);
+
+	dev_info(dev, "Serial\t\t: %08x%08x\n",
+		 system_serial_high, system_serial_low);
+
+	return 0;
+}
+
+static const struct of_device_id rockchip_cpuinfo_of_match[] = {
+	{ .compatible = "rockchip,cpuinfo", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, rockchip_cpuinfo_of_match);
+
+static struct platform_driver rockchip_cpuinfo_driver = {
+	.probe = rockchip_cpuinfo_probe,
+	.driver = {
+		.name = "rockchip-cpuinfo",
+		.of_match_table = rockchip_cpuinfo_of_match,
+	},
+};
+
+static void rockchip_set_cpu_version_from_os_reg(u32 reg)
+{
+	void __iomem *r = ioremap(reg, 0x4);
+
+	if (r) {
+		rockchip_set_cpu_version(readl_relaxed(r) & GENMASK(2, 0));
+		iounmap(r);
+	}
+}
+
+static void px30_init(void)
+{
+	void __iomem *base;
+
+	rockchip_soc_id = ROCKCHIP_SOC_PX30;
+#define PX30_DDR_GRF_BASE	0xFF630000
+#define PX30_DDR_GRF_CON1	0x04
+	base = ioremap(PX30_DDR_GRF_BASE, SZ_4K);
+	if (base) {
+		unsigned int val = readl_relaxed(base + PX30_DDR_GRF_CON1);
+
+		if (((val >> 14) & 0x03) == 0x03)
+			rockchip_soc_id = ROCKCHIP_SOC_PX30S;
+		iounmap(base);
+	}
+}
+
+#define RV1106_OS_REG1	0xff020204
+static void rv1103_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RV1103;
+	rockchip_set_cpu_version_from_os_reg(RV1106_OS_REG1);
+}
+
+static void rv1106_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RV1106;
+	rockchip_set_cpu_version_from_os_reg(RV1106_OS_REG1);
+}
+
+static void rv1109_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RV1109;
+}
+
+static void rv1126_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RV1126;
+}
+
+static void rk3288_init(void)
+{
+	void __iomem *base;
+
+	rockchip_soc_id = ROCKCHIP_SOC_RK3288;
+#define RK3288_HDMI_PHYS	0xFF980000
+	base = ioremap(RK3288_HDMI_PHYS, SZ_4K);
+	if (base) {
+		/* RK3288W HDMI Revision ID is 0x1A */
+		if (readl_relaxed(base + 4) == 0x1A)
+			rockchip_soc_id = ROCKCHIP_SOC_RK3288W;
+		iounmap(base);
+	}
+}
+
+static void rk3126_init(void)
+{
+	void __iomem *base;
+
+	rockchip_soc_id = ROCKCHIP_SOC_RK3126;
+#define RK312X_GRF_PHYS		0x20008000
+#define RK312X_GRF_SOC_CON1	0x00000144
+#define RK312X_GRF_CHIP_TAG	0x00000300
+	base = ioremap(RK312X_GRF_PHYS, SZ_4K);
+	if (base) {
+		if (readl_relaxed(base + RK312X_GRF_CHIP_TAG) == 0x3136) {
+			if (readl_relaxed(base + RK312X_GRF_SOC_CON1) & 0x1)
+				rockchip_soc_id = ROCKCHIP_SOC_RK3126C;
+			else
+				rockchip_soc_id = ROCKCHIP_SOC_RK3126B;
+		}
+		iounmap(base);
+	}
+}
+
+static void rk3308_init(void)
+{
+	void __iomem *base;
+
+	rockchip_soc_id = ROCKCHIP_SOC_RK3308;
+#define RK3308_GRF_PHYS		0xFF000000
+#define RK3308_GRF_CHIP_ID	0x800
+	base = ioremap(RK3308_GRF_PHYS, SZ_4K);
+	if (base) {
+		u32 v = readl_relaxed(base + RK3308_GRF_CHIP_ID);
+
+		if (v == 0x3308)
+			rockchip_soc_id = ROCKCHIP_SOC_RK3308B;
+		if (v == 0x3308c)
+			rockchip_soc_id = ROCKCHIP_SOC_RK3308BS;
+		iounmap(base);
+	}
+}
+
+static void rk3528_init(void)
+{
+	if (of_machine_is_compatible("rockchip,rk3528"))
+		rockchip_soc_id = ROCKCHIP_SOC_RK3528;
+	else if (of_machine_is_compatible("rockchip,rk3528a"))
+		rockchip_soc_id = ROCKCHIP_SOC_RK3528A;
+}
+
+#define RK356X_PMU_GRF_PHYS		0xfdc20000
+#define RK356X_PMU_GRF_SOC_CON0		0x00000100
+#define RK356X_CHIP_VERSION_MASK	0x00008000
+static void rk356x_set_cpu_version(void)
+{
+	void __iomem *base;
+
+	base = ioremap(RK356X_PMU_GRF_PHYS, SZ_4K);
+	if (base) {
+		if (readl_relaxed(base + RK356X_PMU_GRF_SOC_CON0) & RK356X_CHIP_VERSION_MASK)
+			rockchip_set_cpu_version(1);
+		iounmap(base);
+	}
+}
+
+static void rk3566_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RK3566;
+	rk356x_set_cpu_version();
+}
+
+static void rk3567_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RK3567;
+	rk356x_set_cpu_version();
+}
+
+static void rk3568_init(void)
+{
+	rockchip_soc_id = ROCKCHIP_SOC_RK3568;
+	rk356x_set_cpu_version();
+}
+
+int rockchip_soc_id_init(void)
+{
+	if (rockchip_soc_id)
+		return 0;
+
+	if (cpu_is_rk3288()) {
+		rk3288_init();
+	} else if (cpu_is_rk312x()) {
+		if (of_machine_is_compatible("rockchip,rk3128"))
+			rockchip_soc_id = ROCKCHIP_SOC_RK3128;
+		else
+			rk3126_init();
+	} else if (cpu_is_rk3308()) {
+		rk3308_init();
+	} else if (cpu_is_rv1103()) {
+		rv1103_init();
+	} else if (cpu_is_rv1106()) {
+		rv1106_init();
+	} else if (cpu_is_rv1109()) {
+		rv1109_init();
+	} else if (cpu_is_rv1126()) {
+		rv1126_init();
+	} else if (cpu_is_rk3528()) {
+		rk3528_init();
+	}  else if (cpu_is_rk3566()) {
+		rk3566_init();
+	}  else if (cpu_is_rk3567()) {
+		rk3567_init();
+	} else if (cpu_is_rk3568()) {
+		rk3568_init();
+	} else if (cpu_is_px30()) {
+		px30_init();
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(rockchip_soc_id_init);
+#ifndef MODULE
+pure_initcall(rockchip_soc_id_init);
+#endif
+
+static int __init rockchip_cpuinfo_init(void)
+{
+#ifdef MODULE
+	rockchip_soc_id_init();
+#endif
+	return platform_driver_register(&rockchip_cpuinfo_driver);
+}
+subsys_initcall_sync(rockchip_cpuinfo_init);
+
+static void __exit rockchip_cpuinfo_exit(void)
+{
+	platform_driver_unregister(&rockchip_cpuinfo_driver);
+}
+module_exit(rockchip_cpuinfo_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/include/linux/rockchip/cpu.h b/include/linux/rockchip/cpu.h
new file mode 100644
index 000000000000..b33ed7dfdd7f
--- /dev/null
+++ b/include/linux/rockchip/cpu.h
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __LINUX_ROCKCHIP_CPU_H
+#define __LINUX_ROCKCHIP_CPU_H
+
+#include <linux/of.h>
+
+#define ROCKCHIP_CPU_MASK		0xffff0000
+#define ROCKCHIP_CPU_SHIFT		16
+#define ROCKCHIP_CPU_PX30		0x33260000
+#define ROCKCHIP_CPU_RV1103		0x11030000
+#define ROCKCHIP_CPU_RV1106		0x11060000
+#define ROCKCHIP_CPU_RV1109		0x11090000
+#define ROCKCHIP_CPU_RV1126		0x11260000
+#define ROCKCHIP_CPU_RK312X		0x31260000
+#define ROCKCHIP_CPU_RK3288		0x32880000
+#define ROCKCHIP_CPU_RK3308		0x33080000
+#define ROCKCHIP_CPU_RK3528		0x35280000
+#define ROCKCHIP_CPU_RK3566		0x35660000
+#define ROCKCHIP_CPU_RK3567		0x35670000
+#define ROCKCHIP_CPU_RK3568		0x35680000
+
+#if IS_REACHABLE(CONFIG_ROCKCHIP_CPUINFO)
+
+extern unsigned long rockchip_soc_id;
+
+#define ROCKCHIP_CPU_VERION_MASK	0x0000f000
+#define ROCKCHIP_CPU_VERION_SHIFT	12
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return (rockchip_soc_id & ROCKCHIP_CPU_VERION_MASK)
+		>> ROCKCHIP_CPU_VERION_SHIFT;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+	rockchip_soc_id &= ~ROCKCHIP_CPU_VERION_MASK;
+	rockchip_soc_id |=
+		(ver << ROCKCHIP_CPU_VERION_SHIFT) & ROCKCHIP_CPU_VERION_MASK;
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+	if (!code)
+		return;
+
+	rockchip_soc_id &= ~ROCKCHIP_CPU_MASK;
+	rockchip_soc_id |= (code << ROCKCHIP_CPU_SHIFT) & ROCKCHIP_CPU_MASK;
+}
+
+int rockchip_soc_id_init(void);
+
+#else
+
+#define rockchip_soc_id 0
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return 0;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+}
+
+static inline int rockchip_soc_id_init(void)
+{
+	return 0;
+}
+
+#endif
+
+static inline bool cpu_is_px30(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_PX30;
+	return of_machine_is_compatible("rockchip,px30") ||
+	       of_machine_is_compatible("rockchip,px30s") ||
+	       of_machine_is_compatible("rockchip,rk3326") ||
+	       of_machine_is_compatible("rockchip,rk3326s");
+}
+
+static inline bool cpu_is_rv1103(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1103;
+	return of_machine_is_compatible("rockchip,rv1103");
+}
+
+static inline bool cpu_is_rv1106(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1106;
+	return of_machine_is_compatible("rockchip,rv1106");
+}
+
+static inline bool cpu_is_rv1109(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1109;
+	return of_machine_is_compatible("rockchip,rv1109");
+}
+
+static inline bool cpu_is_rv1126(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1126;
+	return of_machine_is_compatible("rockchip,rv1126");
+}
+
+static inline bool cpu_is_rk312x(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK312X;
+	return of_machine_is_compatible("rockchip,rk3126") ||
+	       of_machine_is_compatible("rockchip,rk3126b") ||
+	       of_machine_is_compatible("rockchip,rk3126c") ||
+	       of_machine_is_compatible("rockchip,rk3128");
+}
+
+static inline bool cpu_is_rk3288(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3288;
+	return of_machine_is_compatible("rockchip,rk3288") ||
+	       of_machine_is_compatible("rockchip,rk3288w");
+}
+
+static inline bool cpu_is_rk3308(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3308;
+
+	return of_machine_is_compatible("rockchip,rk3308") ||
+	       of_machine_is_compatible("rockchip,rk3308bs");
+}
+
+static inline bool cpu_is_rk3528(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3528;
+	return of_machine_is_compatible("rockchip,rk3528") ||
+	       of_machine_is_compatible("rockchip,rk3528a");
+}
+
+static inline bool cpu_is_rk3566(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3566;
+	return of_machine_is_compatible("rockchip,rk3566");
+}
+
+static inline bool cpu_is_rk3567(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3567;
+	return of_machine_is_compatible("rockchip,rk3567");
+}
+
+static inline bool cpu_is_rk3568(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3568;
+	return of_machine_is_compatible("rockchip,rk3568");
+}
+
+#define ROCKCHIP_SOC_MASK	(ROCKCHIP_CPU_MASK | 0xff)
+#define ROCKCHIP_SOC_PX30	(ROCKCHIP_CPU_PX30 | 0x00)
+#define ROCKCHIP_SOC_PX30S	(ROCKCHIP_CPU_PX30 | 0x01)
+#define ROCKCHIP_SOC_RV1103     (ROCKCHIP_CPU_RV1103 | 0x00)
+#define ROCKCHIP_SOC_RV1106     (ROCKCHIP_CPU_RV1106 | 0x00)
+#define ROCKCHIP_SOC_RV1109     (ROCKCHIP_CPU_RV1109 | 0x00)
+#define ROCKCHIP_SOC_RV1126     (ROCKCHIP_CPU_RV1126 | 0x00)
+#define ROCKCHIP_SOC_RK3126     (ROCKCHIP_CPU_RK312X | 0x00)
+#define ROCKCHIP_SOC_RK3126B    (ROCKCHIP_CPU_RK312X | 0x10)
+#define ROCKCHIP_SOC_RK3126C    (ROCKCHIP_CPU_RK312X | 0x20)
+#define ROCKCHIP_SOC_RK3128     (ROCKCHIP_CPU_RK312X | 0x01)
+#define ROCKCHIP_SOC_RK3288     (ROCKCHIP_CPU_RK3288 | 0x00)
+#define ROCKCHIP_SOC_RK3288W    (ROCKCHIP_CPU_RK3288 | 0x01)
+#define ROCKCHIP_SOC_RK3308	(ROCKCHIP_CPU_RK3308 | 0x00)
+#define ROCKCHIP_SOC_RK3308B	(ROCKCHIP_CPU_RK3308 | 0x01)
+#define ROCKCHIP_SOC_RK3308BS	(ROCKCHIP_CPU_RK3308 | 0x02)
+#define ROCKCHIP_SOC_RK3528	(ROCKCHIP_CPU_RK3528 | 0x00)
+#define ROCKCHIP_SOC_RK3528A	(ROCKCHIP_CPU_RK3528 | 0x01)
+#define ROCKCHIP_SOC_RK3566	(ROCKCHIP_CPU_RK3566 | 0x00)
+#define ROCKCHIP_SOC_RK3567	(ROCKCHIP_CPU_RK3567 | 0x00)
+#define ROCKCHIP_SOC_RK3568	(ROCKCHIP_CPU_RK3568 | 0x00)
+
+#define ROCKCHIP_SOC(CPU, id, ID) \
+static inline bool soc_is_##id(void) \
+{ \
+	if (rockchip_soc_id) \
+		return ((rockchip_soc_id & ROCKCHIP_SOC_MASK) == ROCKCHIP_SOC_ ##ID); \
+	return of_machine_is_compatible("rockchip,"#id); \
+}
+
+ROCKCHIP_SOC(PX30, px30, PX30)
+ROCKCHIP_SOC(PX30, px30s, PX30S)
+ROCKCHIP_SOC(RV1106, rv1103, RV1103)
+ROCKCHIP_SOC(RV1106, rv1106, RV1106)
+ROCKCHIP_SOC(RV1126, rv1109, RV1109)
+ROCKCHIP_SOC(RV1126, rv1126, RV1126)
+ROCKCHIP_SOC(RK312X, rk3126, RK3126)
+ROCKCHIP_SOC(RK312X, rk3126b, RK3126B)
+ROCKCHIP_SOC(RK312X, rk3126c, RK3126C)
+ROCKCHIP_SOC(RK312X, rk3128, RK3128)
+ROCKCHIP_SOC(RK3288, rk3288, RK3288)
+ROCKCHIP_SOC(RK3288, rk3288w, RK3288W)
+ROCKCHIP_SOC(RK3308, rk3308, RK3308)
+ROCKCHIP_SOC(RK3308, rk3308b, RK3308B)
+ROCKCHIP_SOC(RK3308, rk3308bs, RK3308BS)
+ROCKCHIP_SOC(RK3528, rk3528, RK3528)
+ROCKCHIP_SOC(RK3528, rk3528a, RK3528A)
+ROCKCHIP_SOC(RK3568, rk3566, RK3566)
+ROCKCHIP_SOC(RK3567, rk3567, RK3567)
+ROCKCHIP_SOC(RK3568, rk3568, RK3568)
+
+#endif
-- 
2.43.0

